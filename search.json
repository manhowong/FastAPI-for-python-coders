[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FastAPI for Python Coders",
    "section": "",
    "text": "Welcome\nA friendly FastAPI tutorial for Python coders with zero web background.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>FastAPI for Python Coders</span>"
    ]
  },
  {
    "objectID": "part-01.html",
    "href": "part-01.html",
    "title": "2  The Web as Remote Function Calls",
    "section": "",
    "text": "3 The Web as Remote Function Calls\nIf you’ve ever written a Python script that calls a function, processes data, and prints results, you already know more than you think. Building a web API is essentially the same workflow, except the function call travels over the internet to reach someone else’s computer (or your own, running as a server simultaneously).\nWe’ll anchor this journey by building toward a practical LLM-powered chat application—something that actually streams responses from an AI like a real product. But every skill you learn here applies equally to building inventory systems, data dashboards, or mobile app backends.\nLet’s start by rewiring how you think about calling functions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-01.html#what-if-you-could-call-a-function-on-someone-elses-computer",
    "href": "part-01.html#what-if-you-could-call-a-function-on-someone-elses-computer",
    "title": "2  The Web as Remote Function Calls",
    "section": "3.1 What If You Could Call a Function on Someone Else’s Computer?",
    "text": "3.1 What If You Could Call a Function on Someone Else’s Computer?\nPicture yourself at your desk, running Python in a notebook or script. When you write:\nuser = get_user(user_id=123)\nPython jumps straight into get_user, grabs the data, and hands it back to you instantly. Everything happens in one place: your computer.\nNow imagine you want your friend’s computer (or a server in the cloud) to run that get_user lookup for you. You can’t just type the function name and expect their machine to hear you. You need a agreed-upon protocol for asking, and a format for the answer.\nThat protocol is HTTP, and that request-and-answer dance is the heartbeat of every FastAPI application.\nThink of it like this: instead of calling a function directly, you’re sending a polite letter asking another computer to run a function for you. That letter includes: - The address (the URL, like /users/123) - The action (GET me the data, or POST this new data) - Any arguments (packed as JSON, the internet’s version of a Python dictionary)\nWhen the other computer finishes, it sends a letter back containing your result, or a note (status code) explaining why it couldn’t help .\n\n\n\n\n\n%%{init: {'theme': 'handDrawn'}}%%\nsequenceDiagram\n    participant C as Your Script (Client)\n    participant S as FastAPI Server\n    C-&gt;&gt;S: HTTP Request: GET /users/123\n    Note over S: Server runs get_user(123)\n    S-&gt;&gt;C: HTTP Response: {\"name\": \"Alice\"}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-01.html#the-http-vocab",
    "href": "part-01.html#the-http-vocab",
    "title": "2  The Web as Remote Function Calls",
    "section": "3.2 The HTTP Vocab",
    "text": "3.2 The HTTP Vocab\nGET and POST are the two actions you’ll use most: - GET is for reading or fetching data - e.g. like opening a file or querying a dictionary. - Use GET when you want data but aren’t changing anything on the server. - POST is for actions or creating things - e.g. appending to a list, processing a payment, sending a prompt to an LLM, etc.\nStatus codes are the server’s way of communicating what happened: - 200 means “Success!” - 404 means “Not Found” - 422 means “You sent me bad data”\nJSON is simply the wire format that lets Python dictionaries travel between computers. When you return {\"message\": \"hello\"} from FastAPI, it automatically becomes JSON bytes over the wire, and the client’s Python code receives it as {\"message\": \"hello\"} again. No manual translation required.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-01.html#fastapi-app-in-5-minutes",
    "href": "part-01.html#fastapi-app-in-5-minutes",
    "title": "2  The Web as Remote Function Calls",
    "section": "3.3 FastAPI App in 5 Minutes",
    "text": "3.3 FastAPI App in 5 Minutes\nWe’ll create the smallest possible web application: just enough to see that “remote function call” in action.\n\n3.3.1 Setting Up\nYou’ll need two Python packages: fastapi for the framework, and uvicorn for the server engine that listens for requests and pass them to your code (Think of it as the receptionist who answers the phone and routes calls to your FastAPI app).\npip install fastapi uvicorn[standard]\nCreate a file named main.py and add exactly this:\nfrom fastapi import FastAPI\n\n# This creates your app instance—think of it as the switchboard\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello, world!\"}\nThat @app.get(\"/\") line is doing something powerful: it’s mapping the URL address / to your Python function read_root. When someone (a browser, a script, or later your React frontend) sends a GET request to that address, FastAPI runs your function and ships back the dictionary as JSON.\n\n\n3.3.2 Running the Development Server\nWe’ve just built a simple FastAPI app. To receive requests from other computers, we need to run it on a server. For development purposes, we don’t need to set up a full production server; instead, we can use Uvicorn, which is perfect for testing the app locally. In this case, “other computers” can be your own browser or tools like curl that send HTTP requests to your local machine.\nIn your terminal, navigate to the directory containing main.py, and run:\nuvicorn main:app --reload\nYou should see a message telling you the server is running at http://127.0.0.1:8000. Open your browser and visit that address, or use curl:\ncurl http://localhost:8000/\nThe --reload flag means “watch my code and restart if I make changes”. (Try it out by changing the message in read_root and saving the file—you’ll see the server restart automatically.)\nYou’ll receive {\"message\":\"Hello, world!\"}: As you visit the root URL (http://localhost:8000/), your browser sends an HTTP GET request to the server. FastAPI sees that request, matches it to the read_root function, executes it, and sends back the return value as JSON.\n\n\n3.3.3 Interactive Documentation\nWhile your server is running, visit http://localhost:8000/docs in your browser. You’ll see a beautiful, interactive dashboard called Swagger UI.\nThis page is auto-generated from your Python code. It lists every endpoint you’ve defined (right now, just our root path), shows exactly what JSON structure it expects and returns, and even lets you click “Try it out” to fire test requests without leaving the browser.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-01.html#hands-on-make-the-web-server-talk-back",
    "href": "part-01.html#hands-on-make-the-web-server-talk-back",
    "title": "2  The Web as Remote Function Calls",
    "section": "3.4 Hands-On: Make the Web Server Talk Back",
    "text": "3.4 Hands-On: Make the Web Server Talk Back\nLet’s create two tiny endpoints you’ll actually use in real projects: a health check and an echo service.\n\nHealth check: Every production service needs a simple “are you awake?” endpoint that monitoring tools can ping. Add this to your main.py:\n@app.get(\"/health\")\ndef health_check():\n    return {\"status\": \"ok\"}\nSave the file (Uvicorn will reload automatically), then visit http://localhost:8000/health. You should see your status dictionary.\nEcho endpoint: This will be our playground for sending data (POST) to the server and getting it back. Add this to main.py:\nfrom pydantic import BaseModel\n\nclass Message(BaseModel):\n    text: str\n    sender: str\n\n@app.post(\"/echo\")\ndef echo_message(message: Message):\n    return {\n        \"received\": message.text,\n        \"from\": message.sender,\n        \"response\": f\"Echo: {message.text}\"\n    }\nBaseModel is a way to define the expected structure of the incoming JSON. FastAPI will automatically validate the incoming JSON: if someone sends malformed data, they’ll get a 422 error.\n\nTest it in your Swagger UI at /docs: 1. Click the /echo endpoint, then “Try it out” 2. Paste this JSON into the request body: json    {      \"text\": \"Hello from the internet\",      \"sender\": \"Student\"    } 3. Click Execute. You should see your echoed response. You’ve just built an API that accepts structured input and returns structured output.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-01.html#recap-terms-you-learned",
    "href": "part-01.html#recap-terms-you-learned",
    "title": "2  The Web as Remote Function Calls",
    "section": "3.5 Recap: Terms You Learned",
    "text": "3.5 Recap: Terms You Learned\n\n\n\n\n\n\n\nWeb Term\nWhat it actually means in Python\n\n\n\n\nEndpoint\nThe specific URL address that triggers your function—like a named entry point for remote calls\n\n\nRequest\nThe “letter” sent by the client containing the HTTP method, headers, and JSON body (arguments)\n\n\nResponse\nThe dictionary (or data) your function returns, wrapped with a status code (the exit code of the operation)\n\n\nGET\nThe “read-only” method for fetching data—safe, like accessing a dictionary key\n\n\nPOST\nThe “action” method for sending data to be processed—like calling a function that appends to a list\n\n\nJSON\nThe wire format that lets Python dictionaries travel between computers; think of it as pickle but human-readable and universal\n\n\nStatus Code\nThe numeric result of the operation: 200 for success, 404 for “not found,” 422 for “bad arguments”",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Web as Remote Function Calls</span>"
    ]
  },
  {
    "objectID": "part-02.html",
    "href": "part-02.html",
    "title": "3  From URL Paths to Python Parameters",
    "section": "",
    "text": "4 From URL Paths to Python Parameters\nRemember how Python functions work? Some parameters are required, some have defaults, and you validate what gets passed in. FastAPI endpoints work exactly the same way: the URL just becomes another way to pass arguments to your function.\nTo demonstrate how FastAPI works with URL paths, we will build a simple “Quote of the Day” API along the way.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#path-parameters-required-values-inside-the-url-path",
    "href": "part-02.html#path-parameters-required-values-inside-the-url-path",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.1 Path Parameters: Required Values Inside the URL Path",
    "text": "4.1 Path Parameters: Required Values Inside the URL Path\nWhen you define a Python function, positional arguments are required and ordered:\ndef get_quote(quote_id):\n    return quotes[quote_id]\nIn FastAPI, you declare the same requirement in the URL path by wrapping the variable in curly braces. This is called a path parameter, For example:\n@app.get(\"/quotes/{quote_id}\")\ndef get_quote(quote_id: int):\n    return {\"quote_id\": quote_id, \"message\": \"Here is your quote\"}\nWhen someone visits, say, your-api-url/quotes/42, FastAPI automatically: - Extracts the value of the path parameter from the URL (in this case, 42) - Converts it to an integer (because of the int type hint) - Passes it as the quote_id argument to your get_quote function\nThe path parameter is mandatory (it is part of the URL path) and the value must be convertible to the specified type: - If someone tries to access /quotes/ without providing a quote_id, they’ll get a 404 error since that URL doesn’t match any defined route. - If they try /quotes/abc, FastAPI returns a friendly 422 Unprocessable Entity.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#query-parameters-optional-url-inputs-with-defaults",
    "href": "part-02.html#query-parameters-optional-url-inputs-with-defaults",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.2 Query Parameters: Optional URL Inputs with Defaults",
    "text": "4.2 Query Parameters: Optional URL Inputs with Defaults\nJust like Python functions can have optional keyword arguments with default values, FastAPI allows you to define query parameters that are passed in the URL after a question mark (?), e.g. /quotes?limit=20&author=Shakespeare.\nDeclare them in FastAPI by including them in the function signature but not in the path string:\n@app.get(\"/quotes\")\ndef list_quotes(limit: int = 10, author: str | None = None):\n    return {\"limit\": limit, \"filter_by\": author}\nIf the client provides ?limit=20, your function receives 20. If they omit it, you get your default of 10.\nThe pipe syntax str | None (or Optional[str] in older Python) tells FastAPI this parameter is optional.\nCan you write author: str = None without the | None? Yes, but it’s less explicit. The | None makes it clear that None is an acceptable value, while just str = None could be misinterpreted as a string that defaults to the literal “None”. Using str | None is more idiomatic in modern Python and FastAPI code.\nQuery parameters are perfect for searching, filtering, and pagination.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#request-bodies-when-input-belongs-in-json-not-the-url",
    "href": "part-02.html#request-bodies-when-input-belongs-in-json-not-the-url",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.3 Request Bodies: When Input Belongs in JSON, Not the URL",
    "text": "4.3 Request Bodies: When Input Belongs in JSON, Not the URL\nPath and query parameters work for simple strings and numbers, but what if you need to pass a more complex structure, like dictionary with multiple fields? You don’t want to cram that into the URL. Instead, you send it as JSON in the request body.\nIn Python, you might define a function that takes a dictionary or a dataclass as an argument. In FastAPI, you use Pydantic models to define the expected structure of the incoming JSON. Pydantic models are like Python dataclasses but with built-in validation and parsing.\nFor example, if you want to create a new quote with a text and an author:\nfrom pydantic import BaseModel\n\nclass QuoteCreate(BaseModel):\n    text: str\n    author: str\n    tags: list[str] = []\nNow you can define an endpoint that accepts this model as the request body:\n@app.post(\"/quotes\")\ndef create_quote(quote: QuoteCreate):\n    return {\"stored\": quote.text, \"by\": quote.author}\nWhen a client sends a POST request with JSON like {\"text\": \"Be curious\", \"author\": \"Anonymous\"}: - FastAPI automatically parses the JSON, validates that it has the required fields (text and author), that text and author are strings, and that tags is a list of strings (if provided). - If the client forgets the author field, they receive a detailed 422 error pointing exactly to what’s missing.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#response-models-controlling-exactly-what-your-api-returns",
    "href": "part-02.html#response-models-controlling-exactly-what-your-api-returns",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.4 Response Models: Controlling Exactly What Your API Returns",
    "text": "4.4 Response Models: Controlling Exactly What Your API Returns\nLike request bodies, you can define a response model using Pydantic. This tells FastAPI: “No matter what happens inside this function, the outside world only sees this structure.”\nfrom pydantic import BaseModel\n\nclass Quote(BaseModel):\n    id: int\n    text: str\n    author: str\n\n@app.get(\"/quotes/{quote_id}\", response_model=Quote)\ndef get_quote(quote_id: int):\n    # Even if this dictionary had extra keys like \"internal_note\",\n    # FastAPI would strip them and return only id, text, and author\n    return {\n        \"id\": quote_id,\n        \"text\": \"The journey of a thousand miles...\",\n        \"author\": \"Lao Tzu\"\n    }",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#httpexception-turning-python-errors-into-http-status-codes",
    "href": "part-02.html#httpexception-turning-python-errors-into-http-status-codes",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.5 HTTPException: Turning Python Errors into HTTP Status Codes",
    "text": "4.5 HTTPException: Turning Python Errors into HTTP Status Codes\nIn a Python script, when something goes wrong, you raise an exception and the program crashes or catches it. In a web API, you can’t crash—you must send a polite letter explaining the problem so the client can react appropriately.\nFastAPI provides HTTPException to convert Python errors into proper HTTP status codes:\nfrom fastapi import HTTPException\n\n@app.get(\"/quotes/{quote_id}\")\ndef get_quote(quote_id: int):\n    if quote_id not in quotes_db:\n        raise HTTPException(status_code=404, detail=\"Quote not found\")\n    return quotes_db[quote_id]\nNow, instead of a mysterious server crash (status 500), the client receives a clean 404 Not Found with the message “Quote not found.”\nYou can use different codes for different situations: - 400 for “you sent bad data” (like a ValueError) - 401/403 for authentication issues (like a permission error) - 422 for validation failures (handled by Pydantic)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#the-request-lifecycle-a-visual-map",
    "href": "part-02.html#the-request-lifecycle-a-visual-map",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.6 The Request Lifecycle: A Visual Map",
    "text": "4.6 The Request Lifecycle: A Visual Map\nLet’s visualize exactly what happens when your FastAPI app receives a request. This flow happens for every single endpoint call.\n\n\n\n\n\n---\nconfig:\n    look: handDrawn\n    layout: elk\n    flowchart:\n        nodeSpacing: 20\n        rankSpacing: 30\n        padding: 15\n---\nflowchart TD\n    A[HTTP Request] --&gt; B[[Path & Query Parameter Extraction]]\n    B --&gt; C[[Request Body&lt;br/&gt;Validation]]\n    C --&gt; D{{Route Function Executes}}\n    D --&gt; E[[Response Model&lt;br/&gt;Validation]]\n    E --&gt; F[JSON Response&lt;br/&gt;sent to Client]\n    \n    style A fill:#e8dcc4,stroke:#000\n    style B fill:#fdf1b8,stroke:#000\n    style C fill:#fdf1b8,stroke:#000\n    style D fill:#d8e2dc,stroke:#000\n    style E fill:#fdf1b8,stroke:#000\n    style F fill:#e8dcc4,stroke:#000\n\n\n\n\n\n\nValidation acts as a safety net on both sides of your code: FastAPI ensures the inputs match your Python type hints and the output matches your response model. You focus on the function logic in the middle while FastAPI handles the wire protocol.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#hands-on-a-quote-of-the-day-api",
    "href": "part-02.html#hands-on-a-quote-of-the-day-api",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.7 Hands-On: A Quote of the Day API",
    "text": "4.7 Hands-On: A Quote of the Day API\nLet’s wire everything together into a working mini-application. We’ll build a “Quote of the Day” service that stores quotes in a Python dictionary and exposes a clean “REST” API (i.e, a web API that follows standard HTTP conventions).\nStart fresh with a new file, quotes_app.py:\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Our \"database\": a dictionary in memory\nquotes_db = {}\nnext_id = 1\n\n# Pydantic models for type safety\nclass QuoteCreate(BaseModel):\n    text: str\n    author: str\n\nclass Quote(BaseModel):\n    id: int\n    text: str\n    author: str\n\n# Endpoint to create a new quote\n@app.post(\"/quotes\", response_model=Quote)\ndef create_quote(quote_data: QuoteCreate):\n    global next_id\n    new_quote = {\n        \"id\": next_id,\n        \"text\": quote_data.text,\n        \"author\": quote_data.author\n    }\n    quotes_db[next_id] = new_quote\n    next_id += 1\n    return new_quote\n\n# Endpoint to retrieve a quote by ID\n@app.get(\"/quotes/{quote_id}\", response_model=Quote)\ndef get_quote(quote_id: int):\n    if quote_id not in quotes_db:\n        raise HTTPException(status_code=404, detail=f\"Quote {quote_id} not found\")\n    return quotes_db[quote_id]\n\n# Endpoint to list quotes with pagination\n@app.get(\"/quotes\")\ndef list_quotes(limit: int = 10, skip: int = 0):\n    all_quotes = list(quotes_db.values())\n    return all_quotes[skip : skip + limit]\nTest this in your Swagger UI (/docs): 1. POST to /quotes with {\"text\": \"Short cuts make long delays.\", \"author\": \"JRR Tolkien\"}. Note the returned ID. 2. POST another quote to see the auto-incrementing IDs. 3. GET /quotes/1 to retrieve your first quote by its path parameter. 4. GET /quotes/1 with a non-existent ID to see your 404 error in action. 5. GET /quotes?limit=1 to test the query parameter filtering.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-02.html#recap-terms-you-learned",
    "href": "part-02.html#recap-terms-you-learned",
    "title": "3  From URL Paths to Python Parameters",
    "section": "4.8 Recap: Terms You Learned",
    "text": "4.8 Recap: Terms You Learned\n\n\n\n\n\n\n\nWeb Term\nWhat it actually means in Python\n\n\n\n\nPath Parameter\nA positional argument extracted from the URL path, like /items/{item_id} mapping to def get_item(item_id)\n\n\nQuery Parameter\nA keyword argument with a default value, extracted from the URL query string like ?limit=10\n\n\nRequest Body\nA Pydantic model (like a dataclass) shipped as JSON in the POST request, automatically validated\n\n\nResponse Model\nThe output type hint that guarantees the shape of your returned JSON, filtering extra fields\n\n\nHTTPException\nThe bridge between Python exceptions and HTTP status codes; raise it to send 404, 400, etc.\n\n\nValidation\nThe automatic checking that incoming data matches your Pydantic types, returning 422 if it fails",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>From URL Paths to Python Parameters</span>"
    ]
  },
  {
    "objectID": "part-03.html",
    "href": "part-03.html",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "",
    "text": "5 How FastAPI Handles Many Requests at Once",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#why-one-slow-call-delays-everyone",
    "href": "part-03.html#why-one-slow-call-delays-everyone",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.1 Why One Slow Call Delays Everyone",
    "text": "5.1 Why One Slow Call Delays Everyone\nImagine a restaurant with one waiter handling every table. One table asks for a custom order that takes five minutes to confirm with the kitchen. If the waiter stands there waiting, no other table gets service. That is a blocking server (one server worker/thread handling requests sequentially).\nIn FastAPI terms, this happens during I/O-bound work: waiting on a database, file system, or external API. While that wait is happening, the server thread can’t move on, so other requests queue up.\n\n\n\n\n\nsequenceDiagram\n    participant C1 as Table 1 (Slow Request)\n    participant C2 as Table 2 (Quick Request)\n    participant S as Sync Server (One Waiter)\n\n    C1-&gt;&gt;S: POST /slow-query\n    Note over S: Waiting on external I/O (5s)\n    C2-&gt;&gt;S: GET /health\n    Note over C2: Waiting in line...\n    S-&gt;&gt;C1: Response\n    S-&gt;&gt;C2: Response (after C1)\n\n\n\n\n\n\nWith async, the waiter places Table 1’s request, then serves other tables while waiting. Same waiter, better flow.\n\n\n\n\n\n\nNote“Synchronous” and “Asynchronous” are not the best terms\n\n\n\nIn everyday language, “synchronous” describes events that are “in sync”, i.e. they take the same steps together. It DOES NOT tell us if events happen sequentially or simultaneously, although it is often interpreted as “events happening simultaneously”.\nAnd this is where the confusion arises. In programming, “synchronous” refers to “an event and the code that handles it happen simultaneously”. In other words, the code is “in sync” with the event and cannot handle other events until it finishes. This means that the code can only handle events sequentially, one at a time. So “synchronous” in programming actually means “sequential”, which is the opposite of what the term suggests in everyday language.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#async-and-await-pause-one-request-serve-another",
    "href": "part-03.html#async-and-await-pause-one-request-serve-another",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.2 async and await: Pause One Request, Serve Another",
    "text": "5.2 async and await: Pause One Request, Serve Another\nPython uses two keywords to juggle multiple requests without blocking: async and await. - When you declare a function with async def, you are telling Python: “This function might pause itself to let others work.” - When you write await in front of a slow operation (like an API call), you are saying: “I am stepping aside; let the next customer in line while I wait for this to finish.”\nAsynchronous operations are handled by an event loop (managed by Uvicorn), which keeps track of all the paused functions and wakes them up when their awaited operations complete.\nHere is a simple async endpoint. We will use asyncio.sleep to simulate a slow operation:\nimport asyncio\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/slow\")\nasync def slow_endpoint():\n    # This simulates a 5-second database query or LLM call\n    await asyncio.sleep(5)\n    return {\"message\": \"Sorry for the wait, here is your data\"}\nIf you hit this endpoint in a browser, it takes five seconds. If your friend hits the /health endpoint on the same server during those five seconds, they get an instant response. The server was not blocked.\nJust remember the rule: if a function might take time, make it async def and await the slow parts.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#dependency-injection-reusing-shared-tools-cleanly",
    "href": "part-03.html#dependency-injection-reusing-shared-tools-cleanly",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.3 Dependency Injection: Reusing Shared Tools Cleanly",
    "text": "5.3 Dependency Injection: Reusing Shared Tools Cleanly\nSometimes, your endpoint may need to call an external service (A database, a tool, etc.), so it needs a “client” to talk to that service (not to be confused with the “client” that calls your endpoint). A simple setup might look like this:\nimport httpx # for creating HTTP clients\n\n@app.get(\"/fetch\")\nasync def fetch_data():\n    client = httpx.AsyncClient()\n    response = await client.get(\"https://api.some-external-service.com\")\n    await client.aclose()\n    return {\"status\": response.status_code} # return something\nNotes: - httpx is a popular library for making HTTP requests in Python, and AsyncClient is its asynchronous version. It allows you to create a client object that can make non-blocking HTTP requests. You can use other packages or custom client object. - client.get() sends a GET request to the specified URL. - client.aclose() closes the client object and any open connections.\nCreating a client object involves network setup (it needs to find the server, negotiate encryption, authenticate) and this takes time. If you do this inside the endpoint, every single request will repeat this expensive setup.\nSo can we just create the client object outside the endpoint and reuse it? Let’s try:\nclient = httpx.AsyncClient()\n@app.get(\"/fetch\")\nasync def fetch_data():\n    response = await client.get(\"https://api.some-external-service.com\")\n    return {\"status\": response.status_code}\nThis approach will work, but it has a problem: you need to keep the client object connected for the entire lifetime of the server since it may be used by multiple requests. This is expensive and can lead to resource leaks. You also need to close the client object manually when the server shuts down.\nDependency Injection solves this: you define a function that creates the client object and FastAPI handles the rest. Here’s how it works:\nInstead of creating the client object directly, you define a dependency function that yields the client object (see below), then you declare that your endpoint depends on that function using Depends(). When a request comes in, FastAPI runs the dependency function, gets the client object, and passes it to your endpoint. When the request is done, FastAPI resumes the dependency function to clean up (close connections):\nfrom fastapi import Depends\nimport httpx\n\n# The dependency function\nasync def get_http_client():\n    async with httpx.AsyncClient() as client:\n        yield client  # yield: hand client to the endpoint, then pause\n                      # When the server shuts down, execution resumes here\n\n@app.get(\"/fetch\")\nasync def fetch_data(client: httpx.AsyncClient = Depends(get_http_client)):\n    # FastAPI sees Depends(), runs get_http_client(), passes the yielded client \n    response = await client.get(\"https://api.github.com\")\n    return {\"status\": response.status_code}\nWhy yield instead of return? With return, the function ends immediately—no chance to run cleanup later. yield pauses the function, hands over the client, waits for the endpoint to finish, then resumes so the async with ... as block can close connections.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#keeping-api-keys-safe",
    "href": "part-03.html#keeping-api-keys-safe",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.4 Keeping API Keys Safe",
    "text": "5.4 Keeping API Keys Safe\nWhen you create a client object for an external service, you often need to provide an API key for authentication in addition to the service URL. This is a secret credential that should never be hardcoded in your source code. Instead, we store it in a .env file as an environment variable and use Pydantic to validate them.\nYour .env file (never commit this to Git!) looks like:\nOPENAI_API_KEY=... # If you are using OpenAI, for example\nMODEL_NAME=...\nInstall the helper:\npip install pydantic-settings\nCreate a settings object that reads from your .env file automatically:\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    openai_api_key: str\n    model_name: str = \"gpt-4\"  # Default value if not in env\n    \n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n\n# Now use it in your dependency\ndef get_settings():\n    return settings\nYou can now access settings via dependency injection: settings: Settings = Depends(get_settings).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#hands-on-upgrade-the-quote-api-to-async-depends",
    "href": "part-03.html#hands-on-upgrade-the-quote-api-to-async-depends",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.5 Hands-On: Upgrade the Quote API to Async + Depends",
    "text": "5.5 Hands-On: Upgrade the Quote API to Async + Depends\nLet us bring it all together by upgrading your Quote of the Day API from Part 2. We will convert it to async, add a fake “slow” quote lookup to prove non-blocking behavior, and inject a shared “database connection” (simulated with a simple class).\nFirst, the dependency. We will create a fake database handler that takes time to “connect”:\nimport asyncio\nfrom fastapi import FastAPI, Depends, HTTPException\n\napp = FastAPI()\n\n# Simulating an expensive-to-create resource\nclass QuoteDatabase:\n    def __init__(self):\n        # Imagine this opens a real Postgres connection pool\n        self.quotes = {\n            1: {\"text\": \"Patience is a virtue\", \"author\": \"Unknown\"},\n            2: {\"text\": \"FastAPI is fun\", \"author\": \"You\"}\n        }\n    \n    async def get_by_id(self, quote_id: int):\n        # Simulate network latency to a real database\n        await asyncio.sleep(2)  \n        if quote_id not in self.quotes:\n            raise HTTPException(status_code=404, detail=\"Quote not found\")\n        return self.quotes[quote_id]\n\n# The dependency provider\nasync def get_db():\n    db = QuoteDatabase()  # In production, you'd cache this properly\n    try:\n        yield db\n    finally:\n        # Cleanup would happen here (close connections)\n        pass\nNow, two endpoints to test concurrency. One is slow (uses the database), one is instant:\n@app.get(\"/quotes/{quote_id}\")\nasync def get_quote(quote_id: int, db: QuoteDatabase = Depends(get_db)):\n    # This takes 2 seconds due to the simulated latency inside db.get_by_id\n    quote = await db.get_by_id(quote_id)\n    return quote\n\n@app.get(\"/health\")\nasync def health():\n    # This responds instantly, even if /quotes/1 is grinding away\n    return {\"status\": \"ok\", \"server\": \"async and ready\"}\nTesting workflow: 1. Start the server: uvicorn main:app --reload 2. In one terminal (or browser tab), request the slow quote: curl http://localhost:8000/quotes/1 (This will hang for 2 seconds) 3. Immediately, in a second terminal, hit the health check: curl http://localhost:8000/health\nYou will see the health check return instantly, while the quote request takes its full two seconds. If you had written this synchronously (using time.sleep instead of await asyncio.sleep), the health check would have waited in line behind the slow quote, taking over two seconds itself.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  },
  {
    "objectID": "part-03.html#recap-terms-you-learned",
    "href": "part-03.html#recap-terms-you-learned",
    "title": "4  How FastAPI Handles Many Requests at Once",
    "section": "5.6 Recap: Terms You Learned",
    "text": "5.6 Recap: Terms You Learned\n\n\n\n\n\n\n\nWeb Term\nWhat it actually means in Python\n\n\n\n\nAsync (async def)\nA marker telling Python this function can pause itself to let other work happen\n\n\nAwait (await)\nThe keyword that triggers the pause, specifically for I/O operations like network calls\n\n\nBlocking I/O\nWaiting for external resources (network, disk) in a way that freezes the entire thread\n\n\nEvent Loop\nThe invisible manager (run by Uvicorn) that juggles all your paused async functions\n\n\nDependency Injection\nThe pattern of providing pre-built tools (like database clients) to your functions via Depends()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How FastAPI Handles Many Requests at Once</span>"
    ]
  }
]